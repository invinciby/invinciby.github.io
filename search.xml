<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树莓派ws2812b模型搭建</title>
      <link href="/2022/08/12/%E6%A0%91%E8%8E%93%E6%B4%BEws2812b%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/08/12/%E6%A0%91%E8%8E%93%E6%B4%BEws2812b%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派ws2812b模型搭建"><a href="#树莓派ws2812b模型搭建" class="headerlink" title="树莓派ws2812b模型搭建"></a>树莓派ws2812b模型搭建</h1><iframe src="https://www.bilibili.com/video/BV1G14y1b7s1?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=57d3f23ed548b3abe8c9217e4a28aeba" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%"  height="580" quality="high" > </iframe>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CCPP学习</title>
      <link href="/2022/03/28/CCPP%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/28/CCPP%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="CCPP学习"><a href="#CCPP学习" class="headerlink" title="CCPP学习"></a>CCPP学习</h1><h4 id="1-1-基于栅格的方法"><a href="#1-1-基于栅格的方法" class="headerlink" title="1.1 基于栅格的方法"></a>1.1 基于栅格的方法</h4><p>将区域划分成栅格，搜索连通栅格表示路径。优点：易于建模、存储、处理、更新与分析<br>         Dijkstra算法：通过枚举求解两点间距离最短<br>         Ａ*算法：通代价评估加快搜索</p><h4 id="1-2-基于遗传算法的路径规划"><a href="#1-2-基于遗传算法的路径规划" class="headerlink" title="1.2 基于遗传算法的路径规划"></a>1.2 基于遗传算法的路径规划</h4><p>遗传算法：是计算数学中用于解决最优化的搜索算法，是进化算法的一种<br>        遗传算法通常实现为一种计算机模拟。<br>        对于一个最优化问题，一定数量的候选解（称为个体）的抽像表示（称为染色体）的种群向更好的解进化。传纺上，解用二进制表法(即0和1的串)，但也可以用其他表示方法。进化从完全随机个体的种群开始，之后一代一代发生。在每一代中，整个种群的适应度被评价，从当前种群中随机地选择多个个体（基于他们的适应度），通过自然选择和突变产生新的生命种群，此种群在算法的下一次迭代中成为当前种群。<br>        衍生算法： 退火遗传算法、改进遗传算法等</p><h4 id="1-3CCPP方法分类"><a href="#1-3CCPP方法分类" class="headerlink" title="1.3CCPP方法分类"></a>1.3CCPP方法分类</h4><h6 id="1-2-1-行为覆盖法：随机碰撞法"><a href="#1-2-1-行为覆盖法：随机碰撞法" class="headerlink" title="1.2.1 行为覆盖法：随机碰撞法"></a>1.2.1 行为覆盖法：随机碰撞法</h6><p>原理：机器人根据简单的移动行为,尝试性地覆盖工作区域,如果遇到障碍物,则执行对应的转向命令<br>        缺点：行为全覆盖算法工作效率低,路径规划策略过于简单,面对复杂地形机器人经常无法逃离死区</p><h6 id="1-2-2-区域分割法"><a href="#1-2-2-区域分割法" class="headerlink" title="1.2.2 区域分割法"></a>1.2.2 区域分割法</h6><p>原理：为了使机器人能够逃离死区,同时减少算法的计算量,Jin 等 提出一种基于时空信息的全局导航与局部导航组合的算法。<br>        优点：<br>        该算法一方面能够通过局部计算代替不必要的全局计算,减少了实时决策时局部最优导航的计算量;<br>另一方面通过分层的方式使机器人能够逃离死区。<br>        缺点：<br>        局部与全局的转换过程中,当周围没有未覆盖的区域时,机器人需要扩大邻近区域的面积来寻找未覆盖区域,这将导致覆盖效率的降低,尤其是当未覆盖区域距离机器人较远时</p><h6 id="1-2-3-神经网络法"><a href="#1-2-3-神经网络法" class="headerlink" title="1.2.3 神经网络法"></a>1.2.3 神经网络法</h6><p>原理：利用神经网络的自学习、并行性等特性,增强机器人的“智能”,提高覆盖效率。受神经网络结构与栅格地图单元类似的启发,加拿大学者 S. X.Yang等提出一种基于生物启发神经网络的移动机器人全覆盖路径规划算法,将需要全覆盖的二维栅格地图单元与生物启发神经网络的神经元一一对应起来，机器人实现全覆盖的实时路径规划是由神经元的活性值和机器人的上一位置产生的。该算法完全根据栅格地图单元的性质 (未搜索单元、已搜索单元还是障碍物),决定神经元的输入,直接计算神经元的活性值,不存在神经网络学习过程<br>        优点：算法实时性好,同时可以自动避障与逃离死区。<br>        缺点：但是基于生物启发神经网络的全覆盖算法计算量大,同时此种方法中神经网络模型的衰减率等参数没有最优值,在实现算法时只能通过反复实验确定,参数的设定存在人为不确定因素,从而影响其在线应用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用百度API进行视频翻译</title>
      <link href="/2021/12/06/%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6API%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E7%BF%BB%E8%AF%91/"/>
      <url>/2021/12/06/%E5%88%A9%E7%94%A8%E7%99%BE%E5%BA%A6API%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="利用-百度API进行语音识别"><a href="#利用-百度API进行语音识别" class="headerlink" title="利用 百度API进行语音识别"></a>利用 百度API进行语音识别</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在某次翻墙学习算法的时候，发现了一个学习视频讲的挺不错的，但是没有字幕而且语音是英文，虽然YouTube有翻译的强大功能，现在市场上也有许多软件可以依据视频提取语音文本，但是自己还是想试一试能不能开发出来一个简单的软件。该文主要记录一下自己的学习开发历程。</p><h2 id="首先准备"><a href="#首先准备" class="headerlink" title="首先准备"></a>首先准备</h2><p>首先是根据需求规划大致开发路线：</p><p>最初资源：.MP4</p><p>最终需求结果：（有字幕且有译文的）.MP4</p><blockquote><h4 id="视频-——》》》提取音频文件-——》》》提取文本-——》》》翻译中文"><a href="#视频-——》》》提取音频文件-——》》》提取文本-——》》》翻译中文" class="headerlink" title="视频  ——》》》提取音频文件 ——》》》提取文本 ——》》》翻译中文"></a>视频  ——》》》提取音频文件 ——》》》提取文本 ——》》》翻译中文</h4><h4 id="——》》》传入视频形成字幕-——》》》输出视频"><a href="#——》》》传入视频形成字幕-——》》》输出视频" class="headerlink" title="——》》》传入视频形成字幕 ——》》》输出视频"></a>——》》》传入视频形成字幕 ——》》》输出视频</h4></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="一、提取音频文件"><a href="#一、提取音频文件" class="headerlink" title="一、提取音频文件"></a>一、提取音频文件</h3><p>准备一段长视频(.MP4)，创建项目文件。利用<strong>ffmpeg</strong>将视频格式文件转换为.wav格式文件。</p><h4 id="关于ffmpeg的使用"><a href="#关于ffmpeg的使用" class="headerlink" title="关于ffmpeg的使用"></a>关于ffmpeg的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg &#123;全局参数&#125; &#123;输入文件参数&#125; -i &#123;输入文件&#125; &#123;输出文件参数&#125; &#123;输出文件&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c：指定编码器</span><br><span class="line">-c copy：直接复制，不经过重新编码（这样比较快）</span><br><span class="line">-c:v：指定视频编码器</span><br><span class="line">-c:a：指定音频编码器</span><br><span class="line">-i：指定输入文件</span><br><span class="line">-an：去除音频流</span><br><span class="line">-vn： 去除视频流</span><br><span class="line">-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。</span><br><span class="line">-y：不经过确认，输出时直接覆盖同名文件。</span><br></pre></td></tr></table></figure><h6 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h6><ol><li><p>查看文件信息</p><p> 查看视频文件的元信息</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i (name).mp4</span><br></pre></td></tr></table></figure>  <img src="/img/001.png" alt="Image text" style="zoom:50%;" /> <p> 加入-hide_banner参数可以减少冗余信息的输出，只显示元信息</p> <img src="/img/002.png" alt="Image text" style="zoom:50%;" /></li><li><p>转换编码格式</p><p> 将视频文件从一种编码转成另一种编码。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i [input.file] -c:v libx264 output.mp4 </span><br></pre></td></tr></table></figure> <img src="/img/300.png" alt="Image text" style="zoom:50%;" /></li><li><p>转换容器格式</p><p> 将视频文件从一种容器转到另一种容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c copy output.webm</span><br></pre></td></tr></table></figure><p> 只是转一下容器，内部的编码格式不变，所以使用-c copy指定直接拷贝，不经过转码，这样比较快。 </p></li><li><p>调整码率</p><p> 改变编码的比特率，一般用来将视频文件的体积变小。 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -minrate 964K -maxrate 3856K -bufsize 2000K output.mp4</span><br></pre></td></tr></table></figure><p> ( 指定码率最小为964K，最大为3856K，缓冲区大小为 2000K。 )</p></li><li><p>改变分辨率</p><p> 从1080p转为480p</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf scale=480:-1 output.mp4</span><br></pre></td></tr></table></figure></li><li><p>提取音频</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vn -c:a copy output.aac</span><br></pre></td></tr></table></figure><p> -vn表示去掉视频，-c:a copy表示不改变音频编码，直接拷贝</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i &#123;input.mp4&#125; -ac 1 -ar &#123;采样率(16000)&#125; &#123;output.wav&#125; &amp;&amp; y</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加音轨</p><p> 将外部音轨加入视频，比如添加背景音乐活旁白</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.acc -i intput.mp4 output.mp4</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>截图</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//从指定时间开始，连续对1秒视频进行截图</span><br><span class="line">ffmpeg -y -i input.mp4 -ss 00:01:45 -t 00:00:01 output_%3d.jpg</span><br><span class="line"></span><br></pre></td></tr></table></figure> <img src="/img/040.png" alt="Image text" style="zoom:50%;" /><p> 截图显示：</p> <img src="/img/1638590859217.png" alt="Image text" style="zoom:50%;" /> <p> 如果只需要一张截图</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -ss 00:02:10 -i aimaSpeech.mp4 -y -f image2 -frames:v 1 1.jpg</span><br></pre></td></tr></table></figure><p> -vframes 1 表示只取一帧  -q:v 2 表示输出图片的质量，一般是1~5（1的质量最高）</p></li><li><p>剪裁</p><p> 截取原始视频里面的一个片段，输出为一个新视频。可以指定开始时间（start）和持续时间（duration），也可以指定结束时间（end）。 </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -ss [start] -i [input] -to [end] -c copy [output]</span><br></pre></td></tr></table></figure>   <img src="/img/1638592808467.png" alt="Image text" style="zoom:50%;" />      <img src="/img/1638592788135.png" alt="Image text" style="zoom:50%;" />  </li><li><p>为音频添加封面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loop 1 -i cover.jpg -i input.mp4 -c:v libx264 -c:a aac -b:a 192k -shortest output.mp4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 有两个输入文件，一个是封面图片<code>cover.jpg</code>，另一个是音频文件<code>input.mp3</code>。<code>-loop 1</code>参数表示图片无限循环，<code>-shortest</code>参数表示音频文件结束，输出视频就结束。 </p>  <img src="/img/1638593466979.png" alt="Image text" style="zoom:50%;" />  </li></ol>  <img src="/img/1638593444337.png" alt="Image text" style="zoom:50%;" />  <h3 id="二、提取文本"><a href="#二、提取文本" class="headerlink" title="二、提取文本"></a>二、提取文本</h3><p>我翻阅了多种资料，对于如何实现音频转文本的方法有三种，一种是通过使用 <strong>TensorFlow</strong> 框架利用模型训练，目前有三种模型<strong>HMM</strong>、<strong>DNN</strong>和<strong>End-to-End</strong>。但是由于该方法写代码耗时长工程量大且目前的训练集不够，因此在当前阶段难以实现。第二种方法是通过利用python自带库“speech_recognition”直接实现语音识别，Speech-Recognition 附带 Google Web Speech API 的默认 API 密钥，可直接使用它。 但是该方法准确度不高， 识别率很低 。最后一种也是本次功能实现的方法就是通过使用科大讯飞API或百度API/（SDK也可以）。</p><p>该项目使用的是百度API，这里有一个缺陷就是百度API每次连接只能识别一分钟以内的语音，因此我们需要对长语音进行裁剪缝合处理。</p><p>首先先连接百度API，测试实现代码。</p><p>先在<a href="https://ai.baidu.com/ai-doc/SPEECH/tk4o0bm3v">百度AI开发平台</a>查看技术文档，查询接口要求。</p>  <img src="/img/1638626932583.png" alt="Image text" style="zoom:50%;" />    <img src="/img/1638626967218.png" alt="Image text" style="zoom:50%;" />    <img src="/img/1638627030321.png" alt="Image text" style="zoom:50%;" />  <p>大致使用方法就是，先获取url，设置请求头，发送请求，连接百度语音识别平台传入音频文件，最后获取对应识别结果数据。</p>  <img src="/img/1638627262914.png" alt="Image text" style="zoom:50%;" />  <p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2021/12/3 14:48</span></span><br><span class="line"><span class="comment"># @Author : INVinci</span></span><br><span class="line"><span class="comment"># @File : BYBaiduapi.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span>():</span></span><br><span class="line">    API_Key = <span class="string">&quot;VKyf6r*******X&quot;</span>  <span class="comment"># 官网获取的API_Key</span></span><br><span class="line">    Secret_Key = <span class="string">&quot;Tm****************PfX&quot;</span>  <span class="comment"># 为官网获取的Secret_Key</span></span><br><span class="line">    <span class="comment"># 拼接得到Url</span></span><br><span class="line">    Url = <span class="string">&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=&quot;</span> + API_Key + <span class="string">&quot;&amp;client_secret=&quot;</span> + Secret_Key</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = request.urlopen(Url)</span><br><span class="line"></span><br><span class="line">        result = json.loads(resp.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="comment"># 打印access_token</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;access_token:&quot;</span>, result[<span class="string">&#x27;access_token&#x27;</span>])</span><br><span class="line">        <span class="keyword">return</span> result[<span class="string">&#x27;access_token&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span> request.URLError <span class="keyword">as</span> err:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;token http response http code : &#x27;</span> + <span class="built_in">str</span>(err.code))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 1、获取 access_token</span></span><br><span class="line">    token = get_token()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2、打开需要识别的语音文件</span></span><br><span class="line">    speech_data = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;a2.wav&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> speech_file:</span><br><span class="line">        speech_data = speech_file.read()</span><br><span class="line">    length = <span class="built_in">len</span>(speech_data)</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;file 0.wav length read 0 bytes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3、设置Url里的参数</span></span><br><span class="line">    params = &#123;<span class="string">&#x27;cuid&#x27;</span>: <span class="string">&quot;9E-29-76-BE-C1-98&quot;</span>,  <span class="comment"># 用户唯一标识，用来区分用户，长度为60字符以内。一般用MAC地址</span></span><br><span class="line">              <span class="string">&#x27;token&#x27;</span>: token,  <span class="comment"># 我们获取到的 Access Token</span></span><br><span class="line">              <span class="string">&#x27;dev_pid&#x27;</span>: <span class="number">1737</span>&#125;  <span class="comment"># 1737表示英语 1537 表示识别普通话</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将参数编码</span></span><br><span class="line">    params_query = parse.urlencode(params)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拼接成一个我们需要的完整的完整的url</span></span><br><span class="line">    Url = <span class="string">&#x27;http://vop.baidu.com/server_api&#x27;</span> + <span class="string">&quot;?&quot;</span> + params_query</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4、设置请求头</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;audio/wav; rate=16000&#x27;</span>,  <span class="comment"># 采样率和文件格式</span></span><br><span class="line">        <span class="string">&#x27;Content-Length&#x27;</span>: length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5、发送请求，音频数据直接放在body中</span></span><br><span class="line">    <span class="comment"># 构建Request对象</span></span><br><span class="line">    req = request.Request(Url, speech_data, headers)</span><br><span class="line">    <span class="comment"># 发送请求</span></span><br><span class="line">    res_f = request.urlopen(req)</span><br><span class="line">    result = json.loads(res_f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;识别结果为:&quot;</span>, result[<span class="string">&#x27;result&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(result[<span class="string">&#x27;result&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功实现完语音识别之后，就可以对音频文件进行处理了。将音频文件分为多个一分钟文件然后多次上传得出数据文本。</p><h4 id="·-关于裁剪音频文件的"><a href="#·-关于裁剪音频文件的" class="headerlink" title="· 关于裁剪音频文件的"></a>· 关于裁剪音频文件的</h4><p>需要注意的是，如果音频文件时间长度仅仅是除以一分钟的数值会自动四舍五入，这样容易导致音频文件缺失。因此我们需要找到数值的公因数，找到最适宜的数值（使生成文件数量最少最佳）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlen</span>(<span class="params">leng</span>):</span></span><br><span class="line">    leng = <span class="built_in">int</span>(leng)  <span class="comment"># leng表示视频原长度，此处省去小数点能够减少下面的误差</span></span><br><span class="line">    <span class="keyword">if</span> leng &gt; <span class="number">60</span>:</span><br><span class="line">        dlen = math.sqrt(leng)</span><br><span class="line">        ilen = <span class="built_in">int</span>(dlen)</span><br><span class="line">        <span class="keyword">while</span> ilen &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> leng % ilen * <span class="number">1.0</span> == <span class="number">0</span> <span class="keyword">and</span> ilen &lt; <span class="number">60</span>:  <span class="comment"># 注意这里要确保最后每一个视频长度要小于一分钟，这也是该步的目的</span></span><br><span class="line">                <span class="keyword">if</span> ilen &gt;= leng / ilen:</span><br><span class="line">                    <span class="keyword">return</span> ilen</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> leng / ilen</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ilen = ilen - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> leng</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在百度接口语音识别翻译时，利用遍历剪裁生成的目录进行修改。</p><p>最后生成的结果放入txt文本文档。</p><p>最后利用百度的文本翻译接口（免费）进行文本翻译实现新的文本文件。</p>  <img src="/img/1638783802082.png" alt="Image text" style="zoom:50%;" />  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_api</span>(<span class="params">text</span>):</span></span><br><span class="line">    appid = <span class="string">&#x27;202********473&#x27;</span></span><br><span class="line">    secretKey = <span class="string">&#x27;4*****9&#x27;</span></span><br><span class="line">    myurl = <span class="string">&#x27;http://api.fanyi.baidu.com/api/trans/vip/translate&#x27;</span></span><br><span class="line">    q = text</span><br><span class="line">    fromLang = <span class="string">&#x27;en&#x27;</span></span><br><span class="line">    toLang = <span class="string">&#x27;zh&#x27;</span></span><br><span class="line">    salt = random.randint(<span class="number">32768</span>, <span class="number">65536</span>)</span><br><span class="line">    sign = appid + q + <span class="built_in">str</span>(salt) + secretKey</span><br><span class="line">    m1 = md5()</span><br><span class="line">    m1.update(sign.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    sign = m1.hexdigest()</span><br><span class="line"></span><br><span class="line">    myurl = myurl + <span class="string">&#x27;?appid=&#x27;</span> + appid + <span class="string">&#x27;&amp;q=&#x27;</span> + urllib.parse.quote(</span><br><span class="line">        q) + <span class="string">&#x27;&amp;from=&#x27;</span> + fromLang + <span class="string">&#x27;&amp;to=&#x27;</span> + toLang + <span class="string">&#x27;&amp;salt=&#x27;</span> + <span class="built_in">str</span>(salt) + <span class="string">&#x27;&amp;sign=&#x27;</span> + sign</span><br><span class="line">    <span class="keyword">return</span> myurl</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后依据以上的过程打包，结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding = utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2021/12/6 12:37</span></span><br><span class="line"><span class="comment"># @Author : Vinci</span></span><br><span class="line"><span class="comment"># @File : mainMeun.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> BYBaiduapi</span><br><span class="line"><span class="keyword">import</span> cutwav <span class="keyword">as</span> sw</span><br><span class="line"><span class="keyword">from</span> pydub <span class="keyword">import</span> AudioSegment</span><br><span class="line"><span class="keyword">import</span> mp4ChangeWav</span><br><span class="line"><span class="keyword">import</span> translateByBAIDU</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getlen</span>(<span class="params">leng</span>):</span></span><br><span class="line">    leng = <span class="built_in">int</span>(leng)  <span class="comment"># leng表示视频原长度，此处省去小数点能够减少下面的误差</span></span><br><span class="line">    <span class="keyword">if</span> leng &gt; <span class="number">60</span>:</span><br><span class="line">        dlen = math.sqrt(leng)</span><br><span class="line">        ilen = <span class="built_in">int</span>(dlen)</span><br><span class="line">        <span class="keyword">while</span> ilen &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> leng % ilen * <span class="number">1.0</span> == <span class="number">0</span> <span class="keyword">and</span> ilen &lt; <span class="number">60</span>:  <span class="comment"># 注意这里要确保最后每一个视频长度要小于一分钟，这也是该步的目的</span></span><br><span class="line">                <span class="keyword">if</span> ilen &gt;= leng / ilen:</span><br><span class="line">                    <span class="keyword">return</span> ilen</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> leng / ilen</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ilen = ilen - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> leng</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    interput = <span class="built_in">input</span>(<span class="string">&quot;请输入需要转化的视频路径：&quot;</span>)  <span class="comment"># 需要处理的视频路线</span></span><br><span class="line">    filenames = mp4ChangeWav.getPath(interput)</span><br><span class="line">    filePath = re.findall(<span class="string">r&quot;(.*?)\.mp4&quot;</span>, interput)  <span class="comment"># 切割后文件存储文件夹</span></span><br><span class="line">    wavpath = filenames  <span class="comment"># wav音频文件名字</span></span><br><span class="line">    <span class="comment"># 裁剪视频，进行处理</span></span><br><span class="line">    <span class="keyword">if</span> interput:</span><br><span class="line">        second = AudioSegment.from_wav(wavpath).duration_seconds</span><br><span class="line">        newlength = getlen(second)  <span class="comment"># 切割后每个语音长度</span></span><br><span class="line">        sw.cut_to_time(interput, filePath[<span class="number">0</span>], newlength, wavpath)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接百度进行翻译</span></span><br><span class="line">    filePath = BYBaiduapi.dealmain(filePath[<span class="number">0</span>])</span><br><span class="line">    translateByBAIDU.trans_main(filePath, filePath[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;翻译完成&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="三、结合QT实现界面打包"><a href="#三、结合QT实现界面打包" class="headerlink" title="三、结合QT实现界面打包"></a>三、结合QT实现界面打包</h2><p>太菜了，我好累，考完期末再说吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>路径规划</title>
      <link href="/2021/10/30/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/"/>
      <url>/2021/10/30/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>需求： 根据用户的需要来推荐车位，关键是让人少走路，这就要同时考虑到周边环境、已经内部结构对车位的影响了，我们可以根据内部结构，周边环境对车位进行编码，通过关联用户的目的地，来推荐车位 </p><p>条件需求考虑：</p><p>1，从目的地——出口（指电梯口——对此需要考虑电梯的选择）</p><p>2，从入口——停车位（目的地）</p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628175392241.png" alt="1628175392241" style="zoom: 80%;" /><h1 id="路径规划"><a href="#路径规划" class="headerlink" title="路径规划"></a>路径规划</h1><blockquote><p>学习网址：<a href="https://zhuanlan.zhihu.com/p/51372134">https://zhuanlan.zhihu.com/p/51372134</a></p><p><a href="https://blog.csdn.net/weixin_39594441/article/details/101243168?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162796210616780357299147%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162796210616780357299147&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-101243168.pc_search_result_control_group&amp;utm_term=%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_39594441/article/details/101243168?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162796210616780357299147%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162796210616780357299147&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-101243168.pc_search_result_control_group&amp;utm_term=%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://blog.csdn.net/tjcwt2011/article/details/112463027?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162796210616780357299147%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162796210616780357299147&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112463027.pc_search_result_control_group&amp;utm_term=%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/tjcwt2011/article/details/112463027?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162796210616780357299147%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162796210616780357299147&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112463027.pc_search_result_control_group&amp;utm_term=%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95&amp;spm=1018.2226.3001.4187</a></p><p>提供代码库：<a href="https://github.com/zhm-real/PathPlanning/blob/master/README.md">https://github.com/zhm-real/PathPlanning/blob/master/README.md</a></p></blockquote><h2 id="基于搜索的路径规划"><a href="#基于搜索的路径规划" class="headerlink" title="基于搜索的路径规划"></a>基于搜索的路径规划</h2><h3 id="1-1-图搜索法"><a href="#1-1-图搜索法" class="headerlink" title="1.1 图搜索法"></a>1.1 图搜索法</h3><p>​        <u><strong>广度优先搜索算法</strong>  bfs ——无回溯（队列）</u></p><p>​        <u><strong>深度优先搜索算法</strong>  dfs ——存在回溯（递归）</u></p><hr><h4 id="1-1-1-可视图法-（机器人全局规划的经典算法）"><a href="#1-1-1-可视图法-（机器人全局规划的经典算法）" class="headerlink" title="1.1.1 可视图法 （机器人全局规划的经典算法）"></a><strong>1.1.1 可视图法</strong> （机器人全局规划的经典算法）</h4><p>​    描述：机器人——点        障碍物——多边形</p><p>​    <img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1627980290720.png" alt="1627980290720"  /></p><p>​    将障碍物替换成多边形，再依据S与G的位置连线，最后相当于呈现出图的样子，再根据最短路的求解算法规划最短路径</p><p>​    <strong>缺点：时间问题，灵活性 ( 停车场的车具有流动性，对此方法不适用)</strong></p><hr><h4 id="1-1-2-Dijkstra算法"><a href="#1-1-2-Dijkstra算法" class="headerlink" title="1.1.2 Dijkstra算法"></a>1.1.2 Dijkstra算法</h4><p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628010996708.png" alt="1628010996708"></p><p>​                                                                                &lt;图1.1.2—1&gt;</p><p>从①到⑤，求最短路。</p><h5 id="一般dij"><a href="#一般dij" class="headerlink" title="一般dij"></a><strong>一般dij</strong></h5><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628012234793.png" alt="1628012234793" style="zoom:33%;" /><p>​                                                                                   &lt;图1.1.2—2&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits\stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[mmax];<span class="comment">//待更新的顶点 即从1开始（1不算）每一个对应的i结点所产生的最短路径为dis[i]</span></span><br><span class="line"><span class="keyword">int</span> v[mmax];<span class="comment">//记号，记录每一个顶点是否已经被查</span></span><br><span class="line"><span class="keyword">int</span> map[mmax][mmax]; <span class="comment">//存储地图（需要更新）</span></span><br><span class="line"><span class="comment">/*main操作：</span></span><br><span class="line"><span class="comment">由上面的图举例&lt;图1.1.2—2&gt;</span></span><br><span class="line"><span class="comment">将dis[]赋予第一行——使图搜索从①开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心代码：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij1</span><span class="params">(<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=map[<span class="number">1</span>][i]; <span class="comment">//这里的处理是将dis赋值上从1到所有边的权值</span></span><br><span class="line">    &#125;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    v[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min=inf;</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="comment">//求最短的路</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[j]&amp;&amp;dis[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=dis[j];</span><br><span class="line">           pos=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v[pos]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新dis[]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[j]&amp;&amp;map[pos][j]+dis[pos]&lt;dis[j]&amp;&amp;map[pos][j]&lt;inf)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j]=dis[pos]+map[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="优化dij——堆实现"><a href="#优化dij——堆实现" class="headerlink" title="优化dij——堆实现"></a>优化dij——堆实现</h5><p>①，边优化——vector实行邻接表</p><p>②，时间优化——优先队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits\stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to; <span class="comment">//指向的点</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">//单路径权值</span></span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> to,<span class="keyword">int</span> weight):<span class="built_in">to</span>(to),<span class="built_in">weight</span>(weight)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;edge&gt;&gt; <span class="built_in">G</span>(mmax);</span><br><span class="line"><span class="comment">//核心代码：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij2</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt;Q;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="built_in">pii</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.<span class="built_in">top</span>().second;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!done[u])</span><br><span class="line">        &#123;</span><br><span class="line">            done[u]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                edge&amp; e = G[u][i];</span><br><span class="line">                <span class="keyword">int</span> v=e.to;</span><br><span class="line">                <span class="keyword">int</span> w=e.weight;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&gt;dis[u]+w)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[v]=dis[u]+w;</span><br><span class="line">                    Q.<span class="built_in">push</span>(<span class="built_in">pii</span>(dis[v],v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就目前情况来看，dij算法在获取所要信息上没有什么问题，停车场整体信息已知，需要修改的就是不同停车点的信息，此外可以首先通过计算，对应不同出口将所有的选取方案计算出来，后期只需变动调整停车位即可。</p><p>缺点待补：后续对比参照时间复杂度和空间复杂度 一般停车位（以千计算）</p><hr><h4 id="1-1-3-A-算法（静态路网中求解最短路最有效的方法-）"><a href="#1-1-3-A-算法（静态路网中求解最短路最有效的方法-）" class="headerlink" title="1.1.3 A*算法（静态路网中求解最短路最有效的方法 ）"></a>1.1.3 A*算法（<strong>静态路网</strong>中求解最短路最有效的方法 ）</h4><p><strong>大致理解：</strong></p><p>相较于原始搜索算法，A*算法利用预估权值，减少了搜索次数</p><p>总权值 G = 步次 S + 预估 L</p><p>这里预估 L 有两种方式，即计算点到目的地的距离。</p><p>两个表格（open list &amp;&amp; close list）</p><p><strong>主要程序步骤</strong>：</p><p>1：把起点加入open list </p><p>2：遍历open list ，查找G值最小点 point</p><p>3：把这个点（point）移到close list</p><p>4：此时遍历point点的相邻方格：</p><pre><code> ① 遍历close list ，如果存在，则忽略</code></pre><p>​     ②如果该方格中存在障碍物，则忽略</p><p>​     ③遍历open list ，如果已存在，则检查路径，是否存在一条更好的路径。</p><p>​     ④取最小G的方格加入open list （将此方格设置为下一方格的父节点） ——&gt; 存入open  list时需要注意还得存入G值和该结点的父节点。</p><p>5：①当终点存入open list 时，结束。</p><pre><code>  ②当open list 为空且未存入终点时，说明路径不存在</code></pre><p>​      ③当终点未存入且open list 不为空时，步骤从2开始。</p><p>6：保存路径，从终点开始，依据每次存储的父节点移到到起点。</p><p>核心还是如何取权值 / 求预估值。                                                        </p><p><strong>重点是预估的方法：</strong></p><p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628065349212.png" alt="1628065349212" style="zoom:33%;" /><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628065353474.png" alt="1628065353474" style="zoom:33%;" /><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628065357220.png" alt="1628065357220" style="zoom:33%;" /></p><p><strong>核心思想：贪婪+广搜</strong></p><blockquote><p>这里引申一种 IDA*算法 —— 迭代启发算法  <strong>（待补充）</strong></p><p>相关题目链接：<a href="https://www.luogu.com.cn/problem/P2324">https://www.luogu.com.cn/problem/P2324</a></p></blockquote><h4 id="1-1-4-D-算法（动态路网）"><a href="#1-1-4-D-算法（动态路网）" class="headerlink" title="1.1.4  D*算法（动态路网）"></a><u>1.1.4  D*算法（动态路网）</u></h4><ul><li>维护一个优先队列（OpenList）来对场景中的路径节点进行搜索 </li></ul><blockquote><p>先用A*寻找出路静，再从终点朝起点进行搜索</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()</span><br><span class="line">&#123;</span><br><span class="line">从OPEN表中取k值最小的节点Y;</span><br><span class="line">遍历Y的子节点a,计算a的h值 <span class="built_in">h</span>(a)=<span class="built_in">h</span>(Y)+Y到子节点a的权重<span class="built_in">C</span>(Y,a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a in OPEN)     比较两个a的h值 </span><br><span class="line">    <span class="keyword">if</span>( a的h值小于OPEN表a的h值 )</span><br><span class="line">    &#123;</span><br><span class="line">更新OPEN表中a的h值;k值取最小的h值</span><br><span class="line">          有未受影响的最短路经存在</span><br><span class="line">          <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a in CLOSE) 比较两个a的h值 <span class="comment">//注意是同一个节点的两个不同路径的估价值</span></span><br><span class="line">    <span class="keyword">if</span>( a的h值&lt;CLOSE表的h值 )</span><br><span class="line">    &#123;</span><br><span class="line">   更新CLOSE表中a的h值; k值取最小的h值;将a节点放入OPEN表</span><br><span class="line">     有未受影响的最短路经存在</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">not</span> in both)</span><br><span class="line">        将a插入OPEN表中;　<span class="comment">//还没有排序</span></span><br><span class="line">&#125;</span><br><span class="line">放Y到CLOSE表；</span><br><span class="line">OPEN表比较k值大小进行排序；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> D<em>算法常用于移动机器人领域的路径规划，其衍生算法如Focused D</em> ，D* lite，Field Ｄ* 目前已经是机器人路径规划的核心算法。 </p><p>​        <strong>相较于A*算法的比较：</strong></p><p>​         A ∗ 算法实际上只适用于已经给定了从起始点到终点范围的明确地图或规划空间的情况。然而在很多实际应用场景中，智能体并不完全清楚自己周边的环境信息，或者只拥有一张不完整的地图。那么如果我们基于起始状态的地图进行规划得到的路径大概率是不正确的或是次优的。因此要求智能体具备根据最新状态来实时更新地图以及重规划的能力。一个简单的方法是每次收集到新的信息后就根据更新的地图进行一次上文中的A ∗ 。但是这样对计算资源的损耗与浪费是极大的，尤其是当更新信息不会实际影响到当前求解出的最优路径时。所以更优的方法应该是基于上一个周期的规划路径结合新的更新信息做一定的修复改变。这类算法就是增量式的重规划算法D * 。</p><p>​        D* 的主要特点就是由目标位置开始向起始位置进行路径搜索，当物体由起始位置向目标位置运行过程中，<u>发现路径中存在新的障碍时，对于目标位置到新障碍之间的范围内的路径节点，新的障碍是不会影响到其到目标的路径的。新障碍只会影响的是物体所在位置到障碍之间范围的节点的路径。在这时通过 将新的障碍周围的节点加入到Openlist中进行处理然后向物体所在位置进行传播，能最小程度的减少计算开销。</u></p><h2 id="基于采样的路径规划"><a href="#基于采样的路径规划" class="headerlink" title="基于采样的路径规划"></a>基于采样的路径规划</h2><h3 id="1-2-RRT算法"><a href="#1-2-RRT算法" class="headerlink" title="1.2 RRT算法"></a><strong>1.2 RRT算法</strong></h3><p>通过不断产生随机点生成随机树，再通过结点距离树目的地的距离来形成最终路线</p><p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628179043013.png" alt="1628179043013"></p><p>步骤：</p><p>在图中随机找一个点，连接现有树中点距离随机点最近的那个点（最开始只有一个点即那个点连接），按步长增长。</p><p>判断该边是否通过障碍物，如果没有则加入该边到树中，否则忽略此边。</p><h4 id="1-2-1-RRT"><a href="#1-2-1-RRT" class="headerlink" title="1.2.1 RRT*"></a>1.2.1 RRT*</h4><p>相较于RRT，此算法多了两步（在产生，连接，已插入新的结点之后）</p><p>① 对于新结点——重新选择父结点，这里需要”手动画圆“，即自定义大小的范围，使重新选择的父节点从该范围内寻找。</p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628260435725.png" alt="1628260435725" style="zoom:50%;" /><p>寻找父结点时，选择从0到该新结点的权值和最小</p><p>②对于新结点——同样”手动画圆“（同①），只不过这里将x看做父节点，寻找由此出发的更优子节点</p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628264694154.png" alt="1628264694154" style="zoom:50%;" /><p>寻找子节点时，选择从0到新节点再到子节点的权值和最小</p><h4 id="1-2-2-informed-RRT"><a href="#1-2-2-informed-RRT" class="headerlink" title="1.2.2 informed RRT*"></a><strong>1.2.2 informed RRT</strong>*</h4><p>也是从RRT*出发，找到那条边（相较最短）</p><p>再从两个端点依据下图画椭圆，使随机点集中生成在椭圆内部，继续进行RRT*，这个过程中椭圆会越来越扁（离心率越来越大），最后使线路尽可能最佳。</p><p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628268666815.png" alt="1628268666815"></p><p><img src="C:\Users\vincn\AppData\Roaming\Typora\typora-user-images\1628270996773.png" alt="1628270996773"></p><h2 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h2><p>方向（正反）搜索： <strong>与是否能处理动态规划有关</strong> </p><p> 在静态环境中全局地图信息已知，则无论正向搜索还是反向搜索都可以发挥效能。但是在动态环境中，面对未知地图，要想获得最短路径则需要不断的尝试，正向搜索很容易产生与最优路径背道而驰的现象，而此时反向搜索算法能够很好的处理这种情况。 </p><p>启发式和非启发式： <strong>启发式搜索带来的时效能的提高，避免全局盲目搜寻</strong> </p><p> 启发式算法能够在每次搜索时将搜索方向导向目标点，替代了非启发式算法向四周无规则遍历的局限，正常情况下能够大大提高搜索效率。但是在启发式路径受阻的情况下，搜索效果将适得其反。 </p><p>启发式和增量式： <strong>增量式搜索则代表着迭代信息的二次利用，提高算法效率</strong> </p><p>发式搜索是利用启发函数来对搜索进行指导，从而实现高效的搜索，启发式搜索是一种“智能”搜索。</p><p>增量搜索是对以前的搜索结果信息进行再利用来实现高效搜索，大大减少搜索范围和时间 </p><table><thead><tr><th align="right">算法</th><th align="left">搜索方向</th><th>形式</th><th><strong>特点</strong></th><th align="center">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="right">dijstra</td><td align="left">正向</td><td>无</td><td>静态规划</td><td align="center">一定你找到最短路径</td><td align="left">遍历节点多，计算过于复杂</td></tr><tr><td align="right">A*</td><td align="left">正向</td><td>启发式</td><td>静态规划</td><td align="center">比dijkstra提高了算法搜索效率</td><td align="left"></td></tr><tr><td align="right">D*</td><td align="left">反向</td><td>增量式</td><td>动态规划</td><td align="center">在A*的基础上改进，减少了对相同时间数据的重复计算，提高看路径规划的效率</td><td align="left"></td></tr></tbody></table><p>考虑到停车库的地形和路线整体方正，rrt算法不太适合这种图，因此这里将rrt排除。</p><h1 id="——————附录"><a href="#——————附录" class="headerlink" title="——————附录"></a>——————<strong>附录</strong></h1><ul><li><p>  ​    </p></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
